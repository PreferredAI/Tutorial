# Recommender Systems

This folder contains tutorials, written in Jupyter notebooks, for learning and building recommendation systems.  The tutorials are sorely based on [Cornac](https://cornac.preferred.ai) library.

| Tutorial | Abstract |
| --- | --- |
| [01_introduction.ipynb](01_introduction.ipynb) | In this first foray into recommender systems, we explore a popular recommendation dataset called MovieLens, studying its distributions of users, items, and ratings.  We then apply a basic yet commonly effective recommendation strategy based on item popularity. |
| [02_neighborhood.ipynb](02_neighborhood.ipynb) | One basis for recommendation algorithms is collaborative filtering, where we use the historical rating behaviors to find similarities across users and/or items in arriving at the rating predictions.  Here, we explore a simple, yet highly intuitive collaborative filtering approach that is based on the concept of neighborhood.  Not only does this approach clearly illustrate the collaborative filtering notion of bridging users and items by finding simmilarities, but it also lends itself to interpretability as we will see in this tutorial. |
| [03_matrix_factorization.ipynb](03_matrix_factorization.ipynb) | One apt abstraction for the ratings that users assign to items is a matrix. Most of the time, the rating matrix we observe is very sparse. The challenge then is how to fill in the missing values as accurately as possible.  If we assume that most matrices have a low-rank representation (it can be reconstructed from relatively few basis vectors), then one promising approach is to conduct matrix factorization.  Indeed, matrix factorization is a cornerstone of many recommendation algorithms. |
| [04_implicit_feedback.ipynb](04_implicit_feedback.ipynb) | There are two types of feedback on which most recommender systems would be based. Explicit feedback deals with clear and quantified expression of preferences by a user, in terms of both likes and dislikes. An excellent example would be ratings. However, much more common is implicit feedback, where users provide some positive signals, but the contrast to negative signals may be absent or at least much less evident. An example would be clicks on links or views when browsing.  In this tutorial, we will focus on implicit feedback. |
| [05_multimodality.ipynb](05_multimodality.ipynb) | While preference data in the form of user-item interactions are the backbone of many recommender systems, such data tends to be sparse in nature. One way to address this sparsity is to look beyond the interaction data to the additional information associated with users or with items. The intuition is that items with similarity in "content profiles" would be correlated with similarity in preferences. Multimodality deals with how to model both preference data (one modality) and some content data either on user or item side (other modalities). In this tutorial, we see three forms of additional modalities, namely graph, text, and image, and investigate whether they add value to the the resulting recommendations. |
| [06_contextual_awareness.ipynb](06_contextual_awareness.ipynb) | Traditional matrix factorization assumes that a recommendation is primarily, if not exclusively, based on the specific user and item in question. However, preference may actually be context-sensitive.  The suitable recommendation may depend on various factors such as time of day, current location, etc.  To incorporate such context factors into the model, we associate them with latent vectors that may participate in the prediction by interacting with the user and item latent vectors.  One paradigm for contextual recommendation is Factorization Machine, which is the focus of this tutorial. |
| [07_explanations.ipynb](07_explanations.ipynb) | While the main objective of a recommender system is to identify the items to be recommended to a user, providing explanations to accompany the recommendations would be more persuasive as well as engender trust and transparency.  There are different types of explanations.  In this tutorial, we explore explainable recommendation approaches that rely on user product aspect-level sentiment for modeling explanations. |
| [08_retrieval.ipynb](08_retrieval.ipynb) | A typical recommender system has two phases.  In the first phase (preference learning), which can be done offline, we learn the model from observations.  In the second phase (retrieval), upon the appearance of a user, we retrieve the top-ranked recommendations for that user.  This latter phase needs to be done online.  In this tutorial, we investigate ways to speed up the retrieval phase by avoiding an exhaustive search over all items.  The focus is on matrix factorization-based recommender systems. |